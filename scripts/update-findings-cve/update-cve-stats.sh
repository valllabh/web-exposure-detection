#!/bin/bash

# Update CVE statistics for findings.json using cvemap
# This script queries cvemap for CVE data and updates findings.json with security stats
# Usage: ./scripts/update-cve-stats.sh

set -euo pipefail

FINDINGS_FILE="pkg/webexposure/findings.json"
TEMP_FILE=$(mktemp)
RESULTS_FILE=$(mktemp)

echo "Starting CVE statistics update..."

# Check if cvemap is installed
if ! command -v cvemap &> /dev/null; then
    echo "Error: cvemap is not installed. Install it from: https://github.com/projectdiscovery/cvemap"
    exit 1
fi

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo "Error: jq is not installed. Install it with: brew install jq"
    exit 1
fi

# Function to normalize product names for cvemap queries
normalize_product_name() {
    local display_name="$1"

    # Remove common suffixes and normalize
    echo "$display_name" | sed -E \
        -e 's/\.js$//i' \
        -e 's/\.net$//i' \
        -e 's/ framework$//i' \
        -e 's/ auth$//i' \
        -e 's/ api$//i' \
        -e 's/ spec$//i' \
        -e 's/ collection$//i' \
        -e 's/^sign in with //i' \
        | tr '[:upper:]' '[:lower:]' \
        | tr ' ' '_'
}

# Function to get CVE stats for a product
get_cve_stats() {
    local product="$1"
    local slug="$2"

    echo "  Querying cvemap for: $product (slug: $slug)..."

    # Query cvemap with silent mode to suppress banner
    local cve_data=$(cvemap -p "$product" -j -silent 2>/dev/null)

    # Get current timestamp in ISO 8601 format (always track last check)
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if [ -z "$cve_data" ] || [ "$cve_data" = "[]" ]; then
        echo "    No CVEs found (checked: $timestamp)"
        # Still record the check with 0 stats
        echo "{\"slug\":\"$slug\",\"stats\":{\"critical\":0,\"high\":0,\"medium\":0,\"low\":0,\"total\":0},\"updated\":\"$timestamp\"}" >> "$RESULTS_FILE"
        return 0
    fi

    # Count CVEs by severity
    local critical=$(echo "$cve_data" | jq '[.[] | select(.severity == "critical")] | length')
    local high=$(echo "$cve_data" | jq '[.[] | select(.severity == "high")] | length')
    local medium=$(echo "$cve_data" | jq '[.[] | select(.severity == "medium")] | length')
    local low=$(echo "$cve_data" | jq '[.[] | select(.severity == "low")] | length')
    local total=$((critical + high + medium + low))

    echo "    Found $total CVEs: critical=$critical, high=$high, medium=$medium, low=$low"

    # Store results with timestamp
    echo "{\"slug\":\"$slug\",\"stats\":{\"critical\":$critical,\"high\":$high,\"medium\":$medium,\"low\":$low,\"total\":$total},\"updated\":\"$timestamp\"}" >> "$RESULTS_FILE"

    return 0
}

# Function to check if a finding should be queried
should_query_finding() {
    local slug="$1"
    local display_name="$2"

    # Skip metadata and status findings
    if [[ "$slug" == page.* ]] || [[ "$slug" == server.* ]]; then
        return 1
    fi

    # Skip auth methods (these are features, not products with CVEs)
    if [[ "$slug" == auth.traditional.* ]] || [[ "$slug" == auth.mfa ]] || [[ "$slug" == auth.passwordless ]]; then
        return 1
    fi

    # Skip domain patterns
    if [[ "$slug" == api.domain_pattern ]]; then
        return 1
    fi

    return 0
}

# Initialize results file
> "$RESULTS_FILE"

# Count total findings
total_findings=$(jq 'length' "$FINDINGS_FILE")
echo "Total findings in file: $total_findings"
echo ""

# Extract findings and query cvemap
echo "Processing findings..."
count=0
processed=0
skipped=0

while IFS='|' read -r slug display_name; do
    count=$((count + 1))
    echo "[$count/$total_findings] Processing: $slug - $display_name"

    # Check if we should query this finding
    if ! should_query_finding "$slug" "$display_name"; then
        echo "  Skipping (metadata/auth/domain pattern)"
        skipped=$((skipped + 1))
        continue
    fi

    # Normalize product name
    product=$(normalize_product_name "$display_name")

    # Skip if product name is too generic or empty
    if [ -z "$product" ] || [ "$product" = "-" ]; then
        echo "  Skipping (invalid product name)"
        skipped=$((skipped + 1))
        continue
    fi

    # Get CVE stats
    get_cve_stats "$product" "$slug" || true
    processed=$((processed + 1))

    # Small delay to avoid rate limiting
    sleep 0.5
done < <(jq -r 'to_entries[] | "\(.key)|\(.value.display_name)"' "$FINDINGS_FILE")

echo ""
echo "Processed: $processed findings"
echo "Skipped: $skipped findings"
echo ""

# Check if we collected any results
if [ ! -s "$RESULTS_FILE" ]; then
    echo "No products queried (all findings were skipped)"
    rm -f "$RESULTS_FILE" "$TEMP_FILE"
    exit 0
fi

echo ""
echo "Updating findings.json with CVE statistics..."

# Read stats file into array and merge with findings
jq --slurpfile stats <(jq -s '.' "$RESULTS_FILE") '
  . as $findings |
  ($stats[0] // []) as $all_stats |
  reduce $all_stats[] as $stat (
    $findings;
    .[$stat.slug].security = {
      cve: {
        stats: $stat.stats,
        updated: $stat.updated
      }
    }
  )
' "$FINDINGS_FILE" > "${FINDINGS_FILE}.tmp"

# Replace original file
mv "${FINDINGS_FILE}.tmp" "$FINDINGS_FILE"

# Cleanup
rm -f "$TEMP_FILE" "$RESULTS_FILE"

echo ""
echo "âœ“ CVE statistics updated successfully!"
echo ""
echo "Summary:"
jq -r 'to_entries[] | select(.value.security != null) | "\(.key): critical=\(.value.security.cve.stats.critical), high=\(.value.security.cve.stats.high), medium=\(.value.security.cve.stats.medium), low=\(.value.security.cve.stats.low), total=\(.value.security.cve.stats.total) (updated: \(.value.security.cve.updated))"' "$FINDINGS_FILE"
