#!/usr/bin/env python3

"""
Apply CVE applicability review recommendations.

This script updates findings based on the CVE-APPLICABILITY-REVIEW.md analysis.

Usage: python3 scripts/update-findings-cve/apply-cve-applicability-review.py
"""

import json
from pathlib import Path

FINDINGS_FILE = Path("pkg/webexposure/findings/findings.json")

# Findings that should have cve_applicable=false (managed cloud services)
SHOULD_BE_FALSE = [
    # E-commerce (managed cloud)
    "backend.ecommerce.shopify",
    "backend.ecommerce.bigcommerce",

    # Site builders (managed cloud)
    "backend.sitebuilder.wix",
    "backend.sitebuilder.squarespace",

    # API specifications (not software products)
    "api.spec.openapi",
    "api.spec.swagger",
    "api.spec.wadl",
    "api.spec.wsdl",
    "api.spec.postman",  # Collection format, not the app

    # API content types (not products)
    "api.server.json",
    "api.server.xml",

    # AI cloud services
    "api.ai.openai_endpoint",
    "api.ai.anthropic_endpoint",
    "api.ai.vector_db.pinecone",

    # Gateway cloud services
    "gateway.cloudflare",
    "gateway.akamai",
    "gateway.apigee",
]


def get_reason(slug):
    """Get reason for marking as not applicable."""
    if slug in ["backend.ecommerce.shopify", "backend.ecommerce.bigcommerce"]:
        return "Managed cloud SaaS (vendor handles security)"
    elif slug in ["backend.sitebuilder.wix", "backend.sitebuilder.squarespace"]:
        return "Managed cloud platform (not customer-hosted)"
    elif slug.startswith("api.spec."):
        return "Specification format (not executable software)"
    elif slug in ["api.server.json", "api.server.xml"]:
        return "Content type indicator (not a product)"
    elif slug in ["api.ai.openai_endpoint", "api.ai.anthropic_endpoint", "api.ai.vector_db.pinecone"]:
        return "Managed cloud API (vendor handles security)"
    elif slug in ["gateway.cloudflare", "gateway.akamai", "gateway.apigee"]:
        return "Managed cloud CDN/gateway (vendor handles security)"
    return "Not applicable"


def main():
    print("Applying CVE applicability review recommendations...")
    print()

    # Load findings
    if not FINDINGS_FILE.exists():
        print(f"Error: {FINDINGS_FILE} not found")
        return 1

    with open(FINDINGS_FILE, 'r') as f:
        findings = json.load(f)

    changed_count = 0
    already_correct = 0
    not_found = 0

    print(f"Reviewing {len(SHOULD_BE_FALSE)} findings that should have cve_applicable=false")
    print()

    # Process findings that should be false
    for slug in SHOULD_BE_FALSE:
        if slug not in findings:
            print(f"⚠️  {slug} - Not found in findings.json")
            not_found += 1
            continue

        finding = findings[slug]
        security = finding.get('security', {})
        current_value = security.get('cve_applicable')

        if current_value is False:
            print(f"✓ {slug} - Already set to false")
            already_correct += 1
        else:
            # Initialize security if needed
            if 'security' not in finding:
                finding['security'] = {}

            finding['security']['cve_applicable'] = False
            reason = get_reason(slug)
            print(f"✓ {slug} - Changed to false ({reason})")
            changed_count += 1

    print()
    print("=" * 70)
    print(f"Changed to false: {changed_count}")
    print(f"Already correct: {already_correct}")
    print(f"Not found: {not_found}")
    print()

    # Count final distribution
    true_count = 0
    false_count = 0
    for slug, finding in findings.items():
        security = finding.get('security', {})
        if security.get('cve_applicable') is True:
            true_count += 1
        elif security.get('cve_applicable') is False:
            false_count += 1

    print(f"Final distribution:")
    print(f"  cve_applicable=true:  {true_count} findings (will query CVEs)")
    print(f"  cve_applicable=false: {false_count} findings (will skip)")
    print(f"  Total: {len(findings)} findings")
    print()

    if changed_count > 0:
        # Write updated findings back to file
        with open(FINDINGS_FILE, 'w') as f:
            json.dump(findings, f, indent=2, ensure_ascii=False)
            f.write('\n')

        print(f"✓ Updated {FINDINGS_FILE}")
    else:
        print("No changes needed - all findings already correctly configured")

    return 0


if __name__ == '__main__':
    exit(main())
