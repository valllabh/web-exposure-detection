#!/usr/bin/env python3

"""
Mark findings with cve_applicable=false where CVE data is not applicable.

This script adds the cve_applicable field to findings where CVE/CWE data
should not be queried (auth methods, metadata, patterns, etc.)

Usage: python3 scripts/update-findings-cve/mark-cve-inapplicable.py
"""

import json
from pathlib import Path

FINDINGS_FILE = Path("pkg/webexposure/findings/findings.json")


def should_mark_inapplicable(slug, finding):
    """
    Determine if a finding should be marked with cve_applicable=false.

    Returns True if CVE data is NOT applicable (should mark as false).
    """
    # Metadata and status findings
    if slug.startswith('page.') or slug.startswith('server.'):
        return True

    # All auth methods (these are protocols/services, not products)
    if slug.startswith('auth.'):
        return True

    # Domain patterns (not a product)
    if slug == 'api.domain_pattern':
        return True

    return False


def get_reason(slug):
    """Get human-readable reason for marking as inapplicable."""
    if slug.startswith('page.'):
        return "Metadata field"
    elif slug.startswith('server.'):
        return "Server status/configuration"
    elif slug.startswith('auth.traditional.'):
        return "Authentication method (not a product)"
    elif slug.startswith('auth.enterprise.'):
        return "Enterprise auth service (managed by provider)"
    elif slug.startswith('auth.social.'):
        return "Social auth service (managed by provider)"
    elif slug.startswith('auth.'):
        return "Authentication feature (not a product)"
    elif slug == 'api.domain_pattern':
        return "Domain naming pattern (not a product)"
    else:
        return "Not applicable"


def main():
    print("Marking findings with cve_applicable=false...")
    print()

    # Load findings
    if not FINDINGS_FILE.exists():
        print(f"Error: {FINDINGS_FILE} not found")
        return 1

    with open(FINDINGS_FILE, 'r') as f:
        findings = json.load(f)

    total_findings = len(findings)
    marked_count = 0
    skipped_count = 0

    print(f"Total findings: {total_findings}")
    print()

    # Process each finding
    for slug, finding in findings.items():
        if should_mark_inapplicable(slug, finding):
            # Initialize security object if not present
            if 'security' not in finding:
                finding['security'] = {}

            # Check if already marked
            if finding['security'].get('cve_applicable') is False:
                print(f"✓ {slug} - Already marked")
                skipped_count += 1
            else:
                finding['security']['cve_applicable'] = False
                reason = get_reason(slug)
                print(f"✓ {slug} - Marked as false ({reason})")
                marked_count += 1

    print()
    print(f"Newly marked: {marked_count}")
    print(f"Already marked: {skipped_count}")
    print(f"Total marked: {marked_count + skipped_count}")
    print()

    if marked_count > 0:
        # Write updated findings back to file
        with open(FINDINGS_FILE, 'w') as f:
            json.dump(findings, f, indent=2, ensure_ascii=False)
            f.write('\n')

        print(f"✓ Updated {FINDINGS_FILE}")
    else:
        print("No changes needed")

    return 0


if __name__ == '__main__':
    exit(main())
