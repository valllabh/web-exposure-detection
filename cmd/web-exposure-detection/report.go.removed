package cmd

import (
	"fmt"
	"strings"

	"web-exposure-detection/internal/cli"
	"web-exposure-detection/pkg/webexposure"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// reportCmd represents the report command
var reportCmd = &cobra.Command{
	Use:   "report [domains...]",
	Short: "Regenerate report from existing scan results",
	Long: `Regenerate JSON report from existing Nuclei scan results without running
new domain discovery or vulnerability scans. Uses cached results from previous scan.

Examples:
  web-exposure-detection report example.com
  web-exposure-detection report domain1.com domain2.com
  web-exposure-detection report --debug example.com`,
	Args: cobra.MinimumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		// Get debug flag
		debug, err := cmd.Flags().GetBool("debug")
		if err != nil {
			return fmt.Errorf("failed to get debug flag: %w", err)
		}

		// Parse domain arguments - handle both space-separated and comma-separated
		var domains []string
		for _, arg := range args {
			// Split by comma in case user passed comma-separated domains
			parts := strings.Split(arg, ",")
			for _, part := range parts {
				cleaned := strings.TrimSpace(part)
				if cleaned != "" {
					domains = append(domains, cleaned)
				}
			}
		}

		if len(domains) == 0 {
			return fmt.Errorf("no valid domains provided")
		}

		// Get PDF generator from config/flag
		pdfGenerator := viper.GetString("pdf_generator")

		// Create scanner with configured PDF generator
		scanner, err := webexposure.NewWithPDFGenerator(pdfGenerator)
		if err != nil {
			return fmt.Errorf("failed to create scanner: %w", err)
		}

		// Set debug flag
		scanner.SetDebug(debug)

		// Set up CLI progress handler for command line interface
		progressHandler := cli.NewCLIProgressHandler()
		scanner.SetProgressCallback(progressHandler)

		// Generate report from existing results using new flow architecture
		logger.Info().Msgf("Regenerating report for: %v", domains)
		if debug {
			logger.Info().Msg("Debug mode: enabled (HTML report will be preserved)")
		}

		// Use new flow architecture (handles single domain with proper caching)
		// Loop through domains if multiple are provided
		for _, domain := range domains {
			logger.Info().Msgf("Processing domain: %s", domain)
			// force=false means reuse all cached scan results
			// Empty keywords/templates since we're using existing results
			err = scanner.RunReportFlow(domain, false, []string{}, []string{}, false, false, webexposure.PresetSlow)
			if err != nil {
				return fmt.Errorf("report generation failed for domain %s: %w", domain, err)
			}
		}

		logger.Info().Msg("Report generated successfully")
		return nil
	},
}

func init() {
	rootCmd.AddCommand(reportCmd)
}
